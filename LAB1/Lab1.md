# Вопросы с se.ifmo

## 1. Протокол HTTP. Структура запросов и ответов, методы запросов, коды ответов сервера, заголовки запросов и ответов.

HTTP (англ. HyperText Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных (изначально — в виде гипертекстовых документов в формате «HTML», в настоящий момент используется для передачи произвольных данных). Основой HTTP является технология «клиент-сервер», то есть предполагается существование:
  - Потребителей (клиентов), которые инициируют соединение и посылают запрос;
  - Поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.

HTTP запрос состоит из трех основных частей, которые идут в нем именно в том порядке, который указан ниже. Между заголовками и телом сообщения находится пустая строка (в качестве разделителя), она представляет собой символ перевода строки.
1. строка запроса (Request Line)
2. заголовки (Message Headers)
3. пустая строка (разделитель)
4. тело сообщения (Entity Body) – необязательный параметр

Строка запроса – указывает метод передачи, URL-адрес, к которому нужно обратиться и версию протокола HTTP.
Заголовки – описывают тело сообщений, передают различные параметры и др. сведения и информацию.
Тело сообщения  — это сами данные, которые передаются в запросе.  Тело сообщения – это необязательный параметр и может отсутствовать.

### Методы запросов:
- `GET` запрашивает представление ресурса, может только извлекать данные.
- `HEAD` как GET, только без тела ответа.
- `POST` используется для отправк сущностей определенному ресурсу. Может изменять данные.
- `PUT` создает новый ресурс или заменят предсавление целевого ресурса (в отличае от POST для идентичных наборов двнных будет иметь одинаковый результат).
- `DELETE` удаляет ресурм.
- `CONNECT` устанавливает "туннель" к серверу, определенному по ресурсу.
- `OPTIONS` для описания параметров соединения с ресурсом
- `TRACE` вызов возвращаемого текстового сообщения
- `PATCH` частичное изменение ресурса

### Коды ответов:
1. 1хх: Informational
2. 2xx: Success
3. 3xx: Redirection (перенаправление)
4. 4xx: Client Error
5. 5xx: Server Error 

## 2. Язык разметки HTML. Особенности, основные теги и атрибуты тегов.

Документ состоит из элементов, начало и конец которых обозначаются _тегами_. Некоторые теги не могут содержать текст
(например, `<br>` — перенос строки, `<img>` — картинка, `<input>` — элемент ввода в форме). Их не нужно закрывать:
```html
<!-- плохо -->
<input type="..."></input>
<!-- хорошо -->
<input type="...">
```

В HTML5 введены _семантические_ теги `<header>`, `<footer>`, `<section>`, которые аналогичны `<div>`, но указывают
на логическую структуру.

## 3. Структура HTML-страницы. Объектная модель документа (DOM).

DOM -  программный интерфейс для HTML и XML документов, описывающийструктурированное представление документа и определяющий, как это структура может быть доступна из программ, которые могут изменять ее содержимое. (Другими словами, DOM соединяет веб-страницу с языками описания сценариев).
  
Согласно DOM документ может быть представлен в виде объектов, с которыми можно проихводить манипуляци:

- генерация и добавление узлов
- получение узлов
- изменение узлов
- изменение связей между ними
- удаление узлов

Обращение к узлам происходит с помощью элементов `document` или `window`.

Есть еще BOM - объектная модель браузера. Основное предназначение — управление окнами браузера и обеспечение их взаимодействия. BOM специфична для каждого браузера. Может в создание системных диалогов, управление информацией о параметрах монитора и браузера и всякое такое.
  
## 4. HTML-формы. Задание метода HTTP-запроса. Правила размещения форм на страницах, виды полей ввода.

Форма предназначена для обмена данными между пользователем и сервером. 

Задается с помощью тега `<form>` и могут содержать в себе атрибуты: `action`, содержищий URI обработчика формы (обязательный атрибут), `method` (по умолчанию, GET), `enctype` (тип кодирования), `accept` (MIME-типы для загрузки файлов), `name`, `onsubmit/onreset` (обработчик события submit/reset для скриптов), `accept-character`.

Виды полей:
- Кнопка `<input>`. Типы кнопок `<submit>`, `<image>`, `<reset>`, `<button>`.
- Checkbox.
- Radio.
- Select.
- Text и многострочный textarea.
- Password.
- Hidden (скрытое поле).
- File.

## 5. Каскадные таблицы стилей (CSS). Структура - правила, селекторы. Виды селекторов, особенности их применения. Приоритеты правил. Преимущества CSS перед непосредственным заданием стилей через атрибуты тегов.

Каскадные таблицы стилей (CSS) — это формальный язык для задания визуальных характеристик и оформления веб-документов, отделяющий содержимое (HTML) от внешнего вида (стили). Основной структурной единицей CSS является правило, которое состоит из двух частей: селектора и блока деклараций (свойств с их значениями).

### Структура CSS правил
Правило CSS имеет синтаксис:
```
селектор { свойство1: значение1; свойство2: значение2; ... }
```
- **Селектор** определяет к каким элементам HTML применяется правило.
- **Декларации** указывают стиль для выбранных элементов.

### Виды селекторов в CSS и их применение
- **Селекторы по тегу** (например, `h1`) — применяют стиль ко всем элементам указанного типа.
- **Классовые селекторы** (`.className`) — для элементов с заданным классом.
- **Идентификаторы** (`#id`) — для единственного элемента с конкретным ID.
- **Атрибутные селекторы** (`[attr=value]`) — для элементов с заданным атрибутом.
- **Комбинированные и вложенные селекторы** — для точного выбора элементов с учетом их положения и отношений в DOM.
  
Использование разных селекторов позволяет создавать гибкие и точные стили, улучшая поддержку и читаемость кода.

### Приоритеты правил (каскадность)
CSS подчиняется правилам каскадности и специфичности:
- Правила с `!important` имеют высший приоритет.
- Затем идут inline-стили (внутри атрибута `style` в HTML).
- Далее идут стили из `<style>` в документе.
- Последними идут стили из внешних CSS-файлов.
Если приоритеты равны, применяется последнее в источнике правило.
Это позволяет предсказуемо разрешать конфликты между стилями.

### Преимущества CSS по сравнению с заданием стилей через атрибуты тегов
- **Отделение контента от оформления:** HTML содержит только структуру, а стили централизованно управляются через CSS, что упрощает поддержку и развитие сайта.
- **Удобство управления:** Изменение стиля в одном CSS-файле автоматически применяется ко всем элементам на сайте, экономя время и уменьшая риск ошибок.
- **Снижение объема кода и ускорение загрузки:** Внешний CSS-код кэшируется браузером, уменьшая загрузку данных по сравнению с повторным прописыванием стилей в каждом теге.
- **Гибкость и мощь:** Можно использовать сложные селекторы, каскадность, наследование и медиа-запросы для адаптивного дизайна, чего атрибуты не дают.
- **Разделение ролей:** Дизайнеры и разработчики могут работать параллельно без вмешательства в HTML.

Таким образом, CSS — это мощный и удобный инструмент для современного веб-дизайна с высокой производительностью и гибкостью в работе со стилями [1][2][3][4][6][10].
10] Каскадные таблицы стилей http://iit-web-lectures.readthedocs.io/ru/latest/www/css.html

Селекторы - имя тега, к которому применяется правило. 

### Основные виды селекторов:
- `*` - любые элементы
- `div` элементы с тегом div
- `#id` - элемент по id
- `.class` - элементы с классом class
- `[name="value"]` - селекторы по атрибуту
- `:visited` - псевдоклассы
- `div p` - элементы p, являющиеся потомками div
- `div > p` – только непосредственные потомки
- `div ~ p` – правые соседи: все p на том же уровне вложенности, которые идут после div
- `div + p` – первый правый сосед: p на том же уровне вложенности, который идёт сразу после div

### Приоритеты правил.

1. Самый высокий приоритет имеет атрибут style.
2. Второе по приоритету - присутствие ID в селекторе.
3. Все атрибуты (включая class и псевдоклассы)
4. Самый низкий - селекторы с именами элементов и псевдоэлементами.

`!important` позволяет повысить приоритет стиля.

## 6. LESS, Sass, SCSS. Ключевые особенности, сравнительные характеристики. Совместимость с браузерами, трансляция в "обычный" CSS.

LESS, Sass и SCSS — это популярные CSS-препроцессоры, расширяющие возможности обычного CSS, облегчая разработку сложных стилей. 

## Ключевые особенности и различия

- **LESS (Leaner Style Sheets)**
  - Синтаксис схож с обычным CSS, использует `@` для переменных (например, `@color: #333;`).
  - Поддерживает переменные, вложенность, миксины, операции и функции (Миксины в LESS — это своего рода наборы CSS-свойств, которые можно группировать и многократно использовать в разных селекторах).
  - Может компилироваться на стороне клиента с помощью JavaScript, а также на сервере.
  - Не имеет полноценной логики (условий и циклов), в отличие от Sass/SCSS.
  - Более простой и подходящий для быстрого старта.

- **Sass (Syntactically Awesome Style Sheets)**
  - Это основной препроцессор с двумя синтаксисами: SASS (идентичный Python, с отступами) и SCSS (совместимый с CSS).
  - Поддерживает переменные, вложенность, миксины, наследование, условия, циклы.
  - Имеет богатое сообщество, много готовых библиотек и расширений.
  - Требует компиляции в CSS на сервере или при разработке.

- **SCSS**
  - Подмножество Sass с синтаксисом, полностью совместимым с CSS.
  - Позволяет использовать все возможности Sass с привычным стилем написания.
  - Самый популярный синтаксис, широко поддерживается в современных проектах.

## Трансляция в CSS

Все эти препроцессоры не поддерживаются напрямую браузерами. Код на LESS, Sass/SCSS должен быть **скомпилирован в обычный CSS** (через инструменты как `sass` CLI, webpack-loader, gulp и др.). Полученный CSS уже читается любым браузером.

## Совместимость с браузерами

- Браузеры понимают только обычный CSS, препроцессоры работают на этапе сборки.
- LESS теоретически может компилироваться на клиенте, но это не рекомендуется из-за производительности.
- Sass/SCSS активно используются в современных front-end сборках, гарантирующих поддержку всех современных браузеров.

## Резюме

| Характеристика          | LESS                   | Sass                     | SCSS                      |
|------------------------|------------------------|--------------------------|---------------------------|
| Синтаксис              | Похож на CSS (использует `@`) | Два синтаксиса (отступы и CSS-подобный) | CSS-подобный, расширенный |
| Логика                 | Ограниченная            | Полноценная (условия, циклы) | Полноценная               |
| Компиляция             | На клиенте или сервере  | Только сервер или сборка | Только сервер или сборка  |
| Сообщество и экосистема | Среднее                 | Большое                   | Большое                   |
| Совместимость с браузером | Непосредственно нет     | Непосредственно нет       | Непосредственно нет        |

Все три препроцессора делают написание стилей более удобным и модульным, но чаще всего сегодня предпочтение отдают SCSS за баланс удобства и функционала [1][2][3][4].




## 7. Клиентские сценарии. Особенности, сферы применения. Язык JavaScript.

Особенности клиентских сценариев
	•	Выполняются непосредственно в браузере пользователя.
	•	Позволяют реализовывать интерактивность, валидацию форм, динамическое изменение контента, обработку событий пользователя (например, кликов, нажатий клавиш, перемещения мыши).
	•	Позволяют уменьшить нагрузку на сервер и ускорить отклик интерфейса за счет выполнения части логики локально.
	•	Имеют доступ к DOM (Document Object Model), что позволяет изменять структуру, стиль и содержимое страницы в реальном времени.
	•	Выполнение зависит от возможностей и настроек браузера.
Сферы применения
	•	Интерфейсы и визуальные эффекты на страницах.
	•	Взаимодействие с пользователем (валидация, навигация, анимация).
	•	Асинхронное взаимодействие с сервером через AJAX.
	•	Локальное хранение данных (например, через cookies, localStorage).
	•	Игры, мультимедийные приложения и сложные SPA (Single Page Applications).

JavaScript является объектно-ориентированным языком. JavaScript имеет ряд свойств, присущих функциональным языкам — функции как объекты первого класса, объекты как списки, карринг, анонимные функции, замыкания. Js имеет автоматическое приведение типов, автоматическая сборка мусора, анонимные функции, функции как объекты первого класса (т.е. мб сохранены в переменную, переданны в функцию как аргумент, созданы во время выполнения программы и т.п.)

Основные архитектурные черты:
- динамическая типизация;
- слабая типизация;
- автоматическое управление памятью;
- прототипное программирование;
- функции как объекты первого класса.

### Типы данных 

- `number` -- целые, дробные числа, Infinity, NaN
- `String`
- `boolean`
- `null`
- `undefined` -- «значение не присвоено»
- `object` -- для коллекций и более сложных сущностей

## 8. Версии ECMAScript, новые возможности ES6 и ES7.

ECMAScript — это встраиваемый расширяемый не имеющий средств ввода-вывода язык программирования, используемый в качестве основы для построения других скриптовых языков. Стандартизирован международной организацией ECMA в спецификации. (ECMAScript это стандарт, а JavaScript его реализация). 

Имеет 5 примитивных типов данных — Number, String, Boolean, Null и Undefined; Объектный тип данных — Object и 15 различных видов инструкций.

В особенности можно добавить то, что блок не ограничивает область видимости функции. Если переменная объявляется вне функции, то она
попадает в глобальную область видимости. Функция — это тоже объект.

### ES6

Это обновление добавило новый синтаксис для написания классов и модулей, добавились итераторы и циклы for/of, Python-style генераторы, двоичные данные, лямбда-выражения, типизированные массивы, коллекции, обещания (promises), рефлексию и прокси, усовершенствовали числа и математику. Добавлено ключевое слово let (которое помогает объявить переменной область видимости - блок) и const.

### ES7

Добавлена операция возведения в степень (**), Array.prototype.includes().

## 9. Синхронная и асинхронная обработка HTTP-запросов. AJAX.

Синхронный запрос - запрос с ожидением ответа. (скрипт послал запрос (объект) на сервер и ждет ответ).

Асинхронный запрос - запрос без ожидания ответа от сервера. (скрипт послал запрос (объект) на сервер, но продолжает выполняться, когда данные вернутся вступает в дело событие onreadystatechenge. Сам объект меняет это событие, когда у него меняется свойство readyState. Для события создается собственная функция, в которой проверяется свойство readyState. И как только оно становится равным "4" - это значит, что данные с сервера пришли. Теперь можно полученные данные обрабатывать).

```js
   var request = getXmlHttpRequest(); // создание объекта
   request.onreadystatechenge = function(){ // установка обработчика onreadystatechenge и проверка свойства readyState
       if(request.readyState == 4)
       ...
   }
   request.open('GET', url, true); // готовим запрос
   request.send(null); // посылаем запрос
```
### AJAX

Asynchronous Javascript and XML - подход к построению интерактивных пользовательских интерфейсов веб-приложений, заключающийся в «фоновом» обмене данными браузера с веб-сервером.

Пользователь что-то делает -> скрипт определяет с чем там надо работать -> браузер отправляет запрос на сервер -> сервер возвращает только то, от чего ожидаются изменения -> скрипт вносит изменения обратно (без перезагрузки страницы).

## 10. Библиотека jQuery. Назначение, основные API. Использование для реализации AJAX и работы с DOM.

jQuery - библиотека js, помогающая легко получить доступ к любому элементу DOM и манипулировать ими, предоставляет API для работы с AJAX.

jQuery включается в страницу как внешний файл.

```html 
<script src="jquery-2.2.2.min.js">
```

Вся работа с jQuery ведется с помощью функции $. Работу с jQuery можно разделить на 2 типа:

- Получение jQuery-объекта с помощью функции `$()`.
- Вызов глобальных методов у объекта $.

Типичный пример манипуляции сразу несколькими узлами DOM заключается в вызове $ функции со строкой селектора CSS, что возвращает объект jQuery, содержащий некоторое количество элементов HTML-страницы. Эти элементы затем обрабатываются методами jQuery.

```js
$("div.test").add("p.quote").addClass("blue").slideDown("slow");
//находит элементы div с классом test, все элементы p с классом quote, добавляет им класс blue, ...
```

$.ajax и соответствующие функции позволяют использовать методы AJAX

```js
$.ajax({
  type: "POST",
  url: "some.php",      // обращение к some.php
  data: {name: 'John', location: 'Boston'},   //с какими-то параметрами
  success: function(msg){
    alert( "Data Saved: " + msg );  // получный результат выводится в alert
  }
}); 
```

## 11. Реализация AJAX с помощью SuperAgent.

SuperAgent - API для реализации AJAX:

```js
request
  .post('/api/pet')
  .send({ name: 'Manny', species: 'cat' })
  .set('X-API-Key', 'foobar')
  .set('Accept', 'application/json')
  .end(function(err, res){
  if (err || !res.ok) {
    alert('Oh no! Error');
  } else {
    alert('yay got ' + JSON.stringify(res.body));
  }
});
```

## 12. Серверные сценарии. CGI - определение, назначение, ключевые особенности.

CGI (Common Gateway Interface) — это стандартный интерфейс, который используется для связи веб-сервера с внешними программами или скриптами, выполняющимися на сервере, с целью генерации динамического контента.

## Определение и назначение CGI
- CGI позволяет веб-сервису запускать внешние программы (CGI-скрипты), которые обрабатывают запросы пользователей и формируют динамические ответы.
- Веб-сервер получает HTTP-запрос, передаёт его нужному CGI-скрипту, который выполняется как отдельный процесс.
- CGI-скрипт может взаимодействовать с базами данных, файл-системой или другими ресурсами, затем отправляет сгенерированный результат обратно веб-серверу.
- Сервер возвращает этот результат клиенту (браузеру) в виде веб-страницы с динамическим содержимым.

## Ключевые особенности CGI
- Языки программирования для CGI могут быть разными: Perl, Python, PHP, Ruby, и др.
- Обработка происходит в отдельном процессе, из-за чего CGI имеет низкую производительность при большом числе параллельных запросов.
- Веб-сервер передаёт CGI-скрипту всю информацию о запросе через переменные окружения и стандартный ввод/вывод.
- CGI — один из самых старых и стандартных способов создания динамических веб-страниц.
- Несмотря на устаревание в ряде случаев, CGI по-прежнему используется для простых или наследуемых решений.

Таким образом CGI стандартизирует взаимодействие между сервером и внешними программами, обеспечивая механизм выполнения серверных сценариев и динамической генерации страниц [1][2][3][8].
## 13. FastCGI - особенности технологии, преимущества и недостатки относительно CGI.

FastCGI — это протокол взаимодействия веб-сервера с внешними приложениями, который является развитием технологии CGI и построен для повышения производительности и безопасности веб-приложений. Ключевая особенность FastCGI в том, что он использует постоянно запущенные процессы (демоны), которые остаются в памяти и обрабатывают последовательные запросы, в отличие от CGI, где для каждого запроса создается отдельный процесс, который затем завершается. Это существенно снижает нагрузку на сервер и время отклика.

### Особенности технологии FastCGI
- Работает в режиме демонов, то есть процессы запускаются один раз и переиспользуются для обработки множества запросов.
- Использует Unix Domain Sockets или TCP/IP для связи с веб-сервером, в отличие от CGI, который работает через STDIN и STDOUT.
- Позволяет запускать процессы на удалённых серверах, обеспечивая гибкость архитектуры.
- Поддерживает параллельную обработку запросов несколькими процессами.
- Требует дополнительного программирования и библиотек для поддержки в приложениях.

### Преимущества FastCGI относительно CGI
- **Повышенная производительность** за счет отсутствия необходимости создавать новый процесс на каждый запрос.
- **Меньшая нагрузка на сервер** и экономия ресурсов.
- Возможность **горячего запуска приложений** (процессы постоянно активны).
- Повышенная **масштабируемость** и гибкость за счет поддержки удаленных процессов.
- Улучшенная **безопасность**, так как FastCGI процессы могут быть запущены под другим пользователем и в chroot-окружении.

### Недостатки FastCGI относительно CGI
- Сложнее в программировании и настройке, требует специальных библиотек и знаний.
- Более сложная архитектура и поддержка по сравнению с простым CGI.
- Возможны сложности с отладкой из-за фонового состояния процессов.

Таким образом, FastCGI является более современной и эффективной технологией по сравнению с классическим CGI, особенно для веб-приложений с высокой нагрузкой и требованиями к масштабируемости и производительности [1][2][3][4][7].




## 14. FastCGI сервер на языке Kotlin.

Объяснение кода из Kotlin FastCGI-сервера построчно:

```kotlin
import com.fastcgi.FCGIInterface
import validation.Validate
import check.Checker
import java.nio.charset.StandardCharsets
import java.time.ZoneId
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.util.LinkedHashMap
```
- Подключение необходимых зависимостей и библиотек: FastCGI интерфейс, классы валидации, стандартные библиотеки времени и коллекций.

```kotlin
object Server {
    @JvmStatic
    fun main(args: Array<String>) {
```
- Объявление основного объекта сервера с функцией main, точкой входа в программу.

```kotlin
        val fcgiInterface = FCGIInterface()
        val v = Validate()
        val checker = Checker()
```
- Создание экземпляров классов для работы с FastCGI-запросами, и валидации/проверки данных.

```kotlin
        while (fcgiInterface.FCGIaccept() >= 0) {
```
- Главный цикл обработки запросов FastCGI: метод FCGIaccept ждёт запрос, возвращает >=0 при успешном получении.

```kotlin
            val method = FCGIInterface.request.params.getProperty("REQUEST_METHOD") // извлекаем метод запроса GET POST и тд
```
- Извлечение HTTP метода текущего запроса из параметров (GET, POST и т.п.).

```kotlin
            if (method == "GET") {
                val startTime = System.nanoTime() // стартовое время
```
- Если метод GET, замеряем время начала обработки для подсчёта длительности.

```kotlin
                val req = FCGIInterface.request.params.getProperty("QUERY_STRING") // параметры из URL
```
- Получаем строку параметров запроса из URL после знака ?.

```kotlin
                if (!req.isNullOrEmpty()) {
                    val m = getValues(req) // парсим параметры в ключ:значение
```
- Если параметры есть, разбираем их в словарь ключ-значение с помощью функции getValues.

```kotlin
                    try {
                        val x = m["x"]?.toIntOrNull()
                        val y = m["y"]?.toFloatOrNull()
                        val r = m["r"]?.toFloatOrNull()
                        val timeZone = m["timeZone"] ?: "UTC"
```
- Пытаемся преобразовать значения параметров x в Int, y и r в Float. Извлекаем параметр timeZone или используем "UTC" по умолчанию.

```kotlin
                        if (x != null && y != null && r != null) {
                            val isValid = v.check(x, y, r)
                            val isShot = checker.hit(x, y, r)
                            if (isValid) {
                                println(resp(isShot, x.toString(), y.toString(), r.toString(), startTime, timeZone))
                            } else {
                                println(err(v.getErr()))
                            }
```
- Если парсинг прошёл успешно, проверяем валидность данных через Validate.check и вычисляем попадание (hit) через Checker.hit.
- Если данные валидны - формируем ответ с помощью resp, иначе выдаём ошибку из Validate.

```kotlin
                        } else {
                            println(err("Invalid data"))
                        }
```
- Если парсинг параметров не удался (null), выводим ошибку "Invalid data".

```kotlin
                    } catch (e: Exception) {
                        println(err("Invalid data"))
                    }
```
- Ловим исключения при парсинге/валидации и даём общую ошибку "Invalid data".

```kotlin
                } else {
                    println(err("fill"))
                }
```
- Если параметры запроса отсутствуют, возвращаем ошибку "fill".

```kotlin
            } else {
                println(err("method"))
            }
```
- Если метод не GET, возвращаем ошибку "method".

```kotlin
        }
    }
```
- Конец главного цикла и функции main.

```kotlin
    private fun getValues(inpString: String): LinkedHashMap<String, String> {
        val args = inpString.split("&") //разбивает строку на пары ключ=значение
        val map = LinkedHashMap<String, String>() //  сохраняет порядок добавления элементов
        for (s in args) {
            val arg = s.split("=") // разделяет каждую пару на ключ и значение
            if (arg.size == 2) {
                map[arg[0]] = arg[1]
            }
        }
        return map
    }
```
- Парсинг строки параметров query string в упорядоченный словарь ключ-значение.

```kotlin
    private fun resp(isShoot: Boolean, x: String, y: String, r: String, startTime: Long, timeZone: String): String {
        val zoneId = try { //Создает временную зону, при ошибке использует системную по умолчанию
            ZoneId.of(timeZone)
        } catch (e: Exception) {
            ZoneId.systemDefault()
        }
```
- Функция формирования ответа. Определяет зону времени, если параметр неверный - берёт системную.

```kotlin
        val currentTime = ZonedDateTime.now(zoneId)
        val workTime = currentTime.format(DateTimeFormatter.ofPattern("HH:mm:ss"))
```
- Определяет текущие локальные время и форматирует в часы:минуты:секунды.

```kotlin
        val processingTime = "%.5f".format((System.nanoTime() - startTime).toDouble() / 1_000_000_000)
```
- Считает время обработки запроса в секундах с 5 знаками после запятой.

```kotlin
        val content = """
        {"result":"$isShoot","x":"$x","y":"$y","r":"$r","time":"$processingTime","workTime":"$workTime","error":"all ok"}
    """.trimIndent()
```
- Формирует JSON с данными о результате попадания, параметрах, времени обработки и рабочем времени.

```kotlin
        return """
        Content-Type: application/json; charset=utf-8
        Content-Length: ${content.toByteArray(StandardCharsets.UTF_8).size}
        
        $content
    """.trimIndent()
```
- Формирует HTTP-заголовки Content-Type и Content-Length, затем тело с JSON, возвращает всё как строку.

```kotlin
    private fun err(msg: String): String {
        val content = """
            {"error":"$msg"}
        """.trimIndent()
        return """
            Content-Type: application/json; charset=utf-8
            Content-Length: ${content.toByteArray(StandardCharsets.UTF_8).size}
            
            $content
        """.trimIndent()
    }
}
```
- Функция для ошибки: строит JSON с полем error и HTTP-заголовки Content-Type и Content-Length.

В итоге код представляет собой простой FastCGI сервер на Kotlin (Java-подобный), который:
- Обрабатывает HTTP GET запросы через FastCGI интерфейс,
- Парсит параметры x, y, r, timeZone,
- Проверяет их валидность и вычисляет попадание,
- Формирует JSON-ответ с результатами и временем обработки,
- При ошибках возвращает соответствующие JSON-ошибки с HTTP заголовками.

Это типичный пример сервера, реализующего логику вычислений и отдающего JSON по FastCGI протоколу для интеграции с веб-сервером [custom explanation based on code and general FastCGI Java knowledge; similar referenced examples, , , ].


